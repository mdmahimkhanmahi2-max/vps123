#!/usr/bin/env bash

# ===================================================
#  CLOUD VM MANAGER - NEXT GEN ULTRA EDITION
#                     2025 Edition
# ===================================================
#  Original Creator: MahimOp
#  YouTube : https://www.youtube.com/@mahimxyz
#  Discord : https://discord.gg/zkDNdPpArS
# ===================================================

set -euo pipefail

# Next-Gen Neon Color Theme
RESET="\e[0m"
BOLD="\e[1m"
DIM="\e[2m"
UNDERLINE="\e[4m"

CYAN="\e[96m"
BLUE="\e[94m"
PURPLE="\e[95m"
GREEN="\e[92m"
YELLOW="\e[93m"
RED="\e[91m"
WHITE="\e[97m"

NEON_GREEN="\e[38;5;82m"
NEON_PURPLE="\e[38;5;165m"
NEON_BLUE="\e[38;5;75m"
GLOW="\e[38;5;51m"
DANGER="\e[38;5;196m"

# Paths
VM_DIR="${VM_DIR:-$HOME/vms}"
mkdir -p "$VM_DIR"

# Supported OS Images
declare -A OS_OPTIONS=(
    ["Ubuntu 24.04 LTS"]="ubuntu|noble|https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-amd64.img|ubuntu24|ubuntu|ubuntu"
    ["Ubuntu 22.04 LTS"]="ubuntu|jammy|https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img|ubuntu22|ubuntu|ubuntu"
    ["Debian 12 Bookworm"]="debian|bookworm|https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2|debian12|debian|debian"
    ["Debian 13 Trixie (Daily)"]="debian|trixie|https://cloud.debian.org/images/cloud/trixie/daily/latest/debian-13-generic-amd64-daily.qcow2|debian13|debian|debian"
    ["AlmaLinux 9"]="almalinux|9|https://repo.almalinux.org/almalinux/9/cloud/x86_64/images/AlmaLinux-9-GenericCloud-latest.x86_64.qcow2|almalinux9|alma|alma"
    ["Rocky Linux 9"]="rockylinux|9|https://download.rockylinux.org/pub/rocky/9/images/x86_64/Rocky-9-GenericCloud-latest.x86_64.qcow2|rocky9|rocky|rocky"
)

# Epic Header
display_header() {
    clear
    echo -e "${NEON_BLUE}"
    cat << "EOF"
   _____ _     _   _   _  __      __   __  __ 
  / ____| |   | | | | | \ \    / /  |  \/  |
 | |    | |   | | | | | |\ \  / /   | \  / |
 | |    | |   | | | | | | \ \/ /    | |\/| |
 | |____| |___| |_| | | |  \  /     | |  | |
  \_____|______\___/  |_|   \/      |_|  |_|
                                             
     __     __    __  ____  
     \ \   / /   |  \/  | | 
      \ \_/ /    | \  / | | 
       \   /     | |\/| | | 
        | |      | |  | | |____
        |_|      |_|  |_|______|
                                
EOF
    echo -e "${NEON_PURPLE}${BOLD}                NEXT GEN ULTRA EDITION - 2025${RESET}"
    echo -e "${GLOW}                Advanced Cloud VM Management System${RESET}"
    echo -e "${DIM}      Original Creator: ${BOLD}MahimOp${RESET} ${DIM}| YouTube: @mahimxyz${RESET}"
    echo -e "${DIM}      Discord: https://discord.gg/zkDNdPpArS${RESET}"
    echo -e "${NEON_BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}\n"
}

# Status Functions
progress() { echo -e "${NEON_GREEN}${BOLD}âž¤ $1${RESET}"; }
success() { echo -e "${GREEN}${BOLD}âœ“ $1${RESET}"; }
warning() { echo -e "${YELLOW}${BOLD}! $1${RESET}"; }
error() { echo -e "${RED}${BOLD}âœ˜ $1${RESET}"; }

print_box_header() {
    local text="$1"
    local color="${2:-$NEON_PURPLE}"
    echo -e "${color}${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
    echo -e "${color}${BOLD}â•‘${RESET} ${WHITE}${BOLD}$text$(printf '%*s' $((58 - ${#text})) '') ${color}${BOLD}â•‘${RESET}"
    echo -e "${color}${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}\n"
}

print_menu_option() {
    local num="$1"
    local text="$2"
    local status="${3:-}"
    echo -e "${NEON_BLUE}   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${RESET}"
    echo -e "${NEON_BLUE}   â”‚${RESET} ${WHITE}${BOLD}[${NEON_GREEN}${num}${WHITE}]${RESET} ${CYAN}${text}${status}$(printf '%*s' $((48 - ${#text} - ${#status})) '') ${NEON_BLUE}â”‚${RESET}"
    echo -e "${NEON_BLUE}   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${RESET}"
}

# Dependency Check
check_dependencies() {
    local deps=("qemu-system-x86_64" "wget" "cloud-localds" "qemu-img" "lsof")
    local missing=()
    for dep in "${deps[@]}"; do
        command -v "$dep" &>/dev/null || missing+=("$dep")
    done
    if [ ${#missing[@]} -ne 0 ]; then
        error "Missing dependencies: ${missing[*]}"
        warning "Install with: sudo apt install qemu-system cloud-image-utils wget lsof"
        exit 1
    fi
}

# Helper Functions
get_vm_list() { find "$VM_DIR" -name "*.conf" -exec basename {} .conf \; 2>/dev/null | sort; }

is_vm_running() {
    local vm_name="$1"
    if pgrep -f "qemu-system.*$vm_name" >/dev/null; then
        return 0
    fi
    if load_vm_config "$vm_name" 2>/dev/null && [[ -n "${IMG_FILE:-}" ]] && pgrep -f "qemu-system.*${IMG_FILE}" >/dev/null; then
        return 0
    fi
    return 1
}

load_vm_config() {
    local config_file="$VM_DIR/$1.conf"
    [[ -f "$config_file" ]] && source "$config_file"
    return $?
}

check_image_lock() {
    local img_file=$1
    local vm_name=$2
    if lsof "$img_file" 2>/dev/null | grep -q qemu-system; then
        warning "Image file in use by another QEMU process"
        local pid=$(lsof "$img_file" 2>/dev/null | grep qemu-system | awk '{print $2}' | head -1)
        if [[ -n "$pid" ]] && ps -p "$pid" -o cmd= | grep -q "$vm_name"; then
            progress "Same VM already running (PID: $pid)"
            return 1
        fi
        return 1
    fi
    local lock_file="${img_file}.lock"
    if [[ -f "$lock_file" ]]; then
        if [[ $(find "$lock_file" -mmin +5 2>/dev/null) ]]; then
            warning "Stale lock file detected"
            read -p $'\e[93mRemove stale lock? (y/N): \e[0m' remove_lock
            [[ "$remove_lock" =~ ^[Yy]$ ]] && rm -f "$lock_file" && success "Stale lock removed"
            return 0
        fi
        return 1
    fi
    return 0
}

validate_input() {
    local type=$1 value=$2
    case $type in
        number) [[ "$value" =~ ^[0-9]+$ ]] || { error "Must be a number"; return 1; } ;;
        size) [[ "$value" =~ ^[0-9]+[GgMm]$ ]] || { error "Invalid size (e.g., 20G, 512M)"; return 1; } ;;
        port) [[ "$value" =~ ^[0-9]+$ ]] && [ "$value" -ge 23 ] && [ "$value" -le 65535 ] || { error "Invalid port (23-65535)"; return 1; } ;;
        name) [[ "$value" =~ ^[a-zA-Z0-9_-]+$ ]] || { error "Invalid name format"; return 1; } ;;
        username) [[ "$value" =~ ^[a-z_][a-z0-9_-]*$ ]] || { error "Invalid username"; return 1; } ;;
    esac
    return 0
}

save_vm_config() {
    cat > "$VM_DIR/$VM_NAME.conf" <<EOF
VM_NAME="$VM_NAME"
OS_TYPE="$OS_TYPE"
CODENAME="$CODENAME"
IMG_URL="$IMG_URL"
HOSTNAME="$HOSTNAME"
USERNAME="$USERNAME"
PASSWORD="$PASSWORD"
DISK_SIZE="$DISK_SIZE"
MEMORY="$MEMORY"
CPUS="$CPUS"
SSH_PORT="$SSH_PORT"
GUI_MODE="$GUI_MODE"
PORT_FORWARDS="$PORT_FORWARDS"
IMG_FILE="$IMG_FILE"
SEED_FILE="$SEED_FILE"
CREATED="$(date)"
EOF
    success "Configuration saved"
}

setup_vm_image() {
    progress "Preparing VM image..."
    mkdir -p "$VM_DIR"

    if [[ ! -f "$IMG_FILE" ]]; then
        progress "Downloading image from $IMG_URL..."
        wget --progress=bar:force:noscroll "$IMG_URL" -O "$IMG_FILE.tmp" && mv "$IMG_FILE.tmp" "$IMG_FILE"
    else
        progress "Image already exists"
    fi

    qemu-img resize "$IMG_FILE" "$DISK_SIZE" >/dev/null 2>&1 && progress "Disk resized to $DISK_SIZE"

    cat > user-data <<EOF
#cloud-config
hostname: $HOSTNAME
ssh_pwauth: true
disable_root: false
users:
  - name: $USERNAME
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash
    passwd: $(openssl passwd -6 "$PASSWORD")
chpasswd:
  list: |
    root:$PASSWORD
    $USERNAME:$PASSWORD
  expire: false
EOF
    cat > meta-data <<EOF
instance-id: iid-$VM_NAME
local-hostname: $HOSTNAME
EOF

    cloud-localds "$SEED_FILE" user-data meta-data
    success "Cloud-init seed created"
}

create_new_vm() {
    display_header
    print_box_header "CREATE NEW VM"

    local os_list=("${!OS_OPTIONS[@]}")
    local os_count=${#os_list[@]}
    for ((i=0; i<os_count; i++)); do
        echo -e " ${NEON_GREEN}$((i+1))${RESET} ${os_list[$i]}"
    done

    local choice
    while true; do
        read -p $'\e[96mSelect OS [1-'$os_count']: \e[0m' choice
        [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "$os_count" ] && break
        error "Invalid selection"
    done

    local selected_index=$((choice - 1))
    local selected_os="${os_list[$selected_index]}"
    IFS='|' read -r OS_TYPE CODENAME IMG_URL DEFAULT_HOSTNAME DEFAULT_USERNAME DEFAULT_PASSWORD <<< "${OS_OPTIONS[$selected_os]}"

    read -p $'\e[96mVM Name (default: '$DEFAULT_HOSTNAME'): \e[0m' VM_NAME
    VM_NAME=${VM_NAME:-$DEFAULT_HOSTNAME}
    until validate_input name "$VM_NAME" && [[ ! -f "$VM_DIR/$VM_NAME.conf" ]]; do
        error "Name invalid or exists"
        read -p $'\e[96mNew name: \e[0m' VM_NAME
    done

    read -p $'\e[96mHostname (default: '$VM_NAME'): \e[0m' HOSTNAME
    HOSTNAME=${HOSTNAME:-$VM_NAME}
    until validate_input name "$HOSTNAME"; do read -p $'\e[96mHostname: \e[0m' HOSTNAME; done

    read -p $'\e[96mUsername (default: '$DEFAULT_USERNAME'): \e[0m' USERNAME
    USERNAME=${USERNAME:-$DEFAULT_USERNAME}
    until validate_input username "$USERNAME"; do read -p $'\e[96mUsername: \e[0m' USERNAME; done

    read -s -p $'\e[96mPassword: \e[0m' PASSWORD; echo
    PASSWORD=${PASSWORD:-$DEFAULT_PASSWORD}

    read -p $'\e[96mDisk Size (default: 20G): \e[0m' DISK_SIZE
    DISK_SIZE=${DISK_SIZE:-20G}
    until validate_input size "$DISK_SIZE"; do read -p $'\e[96mDisk Size: \e[0m' DISK_SIZE; done

    read -p $'\e[96mRAM MB (default: 2048): \e[0m' MEMORY
    MEMORY=${MEMORY:-2048}
    until validate_input number "$MEMORY"; do read -p $'\e[96mRAM: \e[0m' MEMORY; done

    read -p $'\e[96mCPUs (default: 2): \e[0m' CPUS
    CPUS=${CPUS:-2}
    until validate_input number "$CPUS"; do read -p $'\e[96mCPUs: \e[0m' CPUS; done

    read -p $'\e[96mSSH Port (default: 2222): \e[0m' SSH_PORT
    SSH_PORT=${SSH_PORT:-2222}
    until validate_input port "$SSH_PORT" && ! ss -tln | grep -q ":$SSH_PORT "; do
        error "Port invalid or in use"
        read -p $'\e[96mSSH Port: \e[0m' SSH_PORT
    done

    read -p $'\e[96mGUI Mode? (y/n, default n): \e[0m' gui
    GUI_MODE=false
    [[ $gui =~ ^[Yy]$ ]] && GUI_MODE=true

    read -p $'\e[96mExtra Port Forwards (e.g., 8080:80): \e[0m' PORT_FORWARDS

    IMG_FILE="$VM_DIR/$VM_NAME.img"
    SEED_FILE="$VM_DIR/$VM_NAME-seed.iso"

    setup_vm_image
    save_vm_config
    success "VM '$VM_NAME' created successfully!"
    progress "SSH: ssh -p $SSH_PORT $USERNAME@localhost"
}

start_vm() {
    local vm_name=$1
    load_vm_config "$vm_name" || return 1

    if ! check_image_lock "$IMG_FILE" "$vm_name"; then
        error "Cannot start: image locked"
        return 1
    fi

    if is_vm_running "$vm_name"; then
        warning "VM already running"
        return 1
    fi

    [[ ! -f "$SEED_FILE" ]] && setup_vm_image

    local qemu_cmd=(
        qemu-system-x86_64 -enable-kvm -m "$MEMORY" -smp "$CPUS" -cpu host
        -drive "file=$IMG_FILE,format=qcow2,if=virtio"
        -drive "file=$SEED_FILE,format=raw,if=virtio"
        -boot order=c
        -device virtio-net-pci,netdev=n0
        -netdev "user,id=n0,hostfwd=tcp::$SSH_PORT-:22"
        -device virtio-balloon-pci
        -object rng-random,filename=/dev/urandom,id=rng0
        -device virtio-rng-pci,rng=rng0
    )

    if [[ -n "$PORT_FORWARDS" ]]; then
        IFS=',' read -ra forwards <<< "$PORT_FORWARDS"
        local net_id=1
        for forward in "${forwards[@]}"; do
            IFS=':' read -r host_port guest_port <<< "$forward"
            qemu_cmd+=(-netdev "user,id=n$net_id,hostfwd=tcp::$host_port-:$guest_port")
            qemu_cmd+=(-device virtio-net-pci,netdev=n$net_id)
            ((net_id++))
        done
    fi

    if [[ "$GUI_MODE" == true ]]; then
        qemu_cmd+=(-vga virtio -display gtk,gl=on)
    else
        qemu_cmd+=(-nographic -serial mon:stdio)
    fi

    progress "Launching $vm_name..."
    progress "SSH: ssh -p $SSH_PORT $USERNAME@localhost"
    "${qemu_cmd[@]}"
    progress "VM stopped"
}

stop_vm() {
    local vm_name=$1
    load_vm_config "$vm_name" || return 1

    if ! is_vm_running "$vm_name"; then
        warning "VM not running"
        rm -f "${IMG_FILE}.lock" 2>/dev/null
        return
    fi

    progress "Stopping $vm_name..."
    pkill -f "qemu-system.*$IMG_FILE" || true
    sleep 2
    if is_vm_running "$vm_name"; then
        warning "Force stopping..."
        pkill -9 -f "qemu-system.*$IMG_FILE" || true
    fi
    rm -f "${IMG_FILE}.lock" 2>/dev/null
    success "VM stopped"
}

delete_vm() {
    local vm_name=$1
    load_vm_config "$vm_name" || return 1

    warning "This will PERMANENTLY delete '$vm_name'!"
    read -p $'\e[93mType YES to confirm: \e[0m' confirm
    [[ "$confirm" == "YES" ]] || { progress "Cancelled"; return; }

    is_vm_running "$vm_name" && stop_vm "$vm_name"
    rm -f "$IMG_FILE" "$SEED_FILE" "$VM_DIR/$vm_name.conf" "${IMG_FILE}.lock"
    success "VM '$vm_name' deleted"
}

show_vm_info() {
    local vm_name=$1
    load_vm_config "$vm_name" || return 1

    print_box_header "VM INFO: $vm_name"
    echo -e "${WHITE}OS:${RESET} $OS_TYPE $CODENAME"
    echo -e "${WHITE}Hostname:${RESET} $HOSTNAME"
    echo -e "${WHITE}User:${RESET} $USERNAME"
    echo -e "${WHITE}SSH:${RESET} ssh -p $SSH_PORT $USERNAME@localhost"
    echo -e "${WHITE}RAM:${RESET} $MEMORY MB | ${WHITE}CPU:${RESET} $CPUS"
    echo -e "${WHITE}Disk:${RESET} $DISK_SIZE | ${WHITE}GUI:${RESET} $GUI_MODE"
    echo -e "${WHITE}Forwards:${RESET} ${PORT_FORWARDS:-None}"
    echo -e "${WHITE}Created:${RESET} $CREATED"
    echo -e "${WHITE}Status:${RESET} $(is_vm_running "$vm_name" && echo "ðŸŸ¢ Running" || echo "ðŸ”´ Stopped")"

    read -p $'\e[93mPress Enter...\e[0m' -r
}

edit_vm_config() {
    local vm_name=$1
    load_vm_config "$vm_name" || return 1

    while true; do
        print_box_header "EDIT $vm_name"
        echo "1) Hostname ($HOSTNAME)"
        echo "2) Username ($USERNAME)"
        echo "3) Password"
        echo "4) SSH Port ($SSH_PORT)"
        echo "5) GUI Mode ($GUI_MODE)"
        echo "6) Port Forwards ($PORT_FORWARDS)"
        echo "7) RAM ($MEMORY MB)"
        echo "8) CPUs ($CPUS)"
        echo "9) Disk Size ($DISK_SIZE)"
        echo "0) Back"

        read -p $'\e[96mChoice: \e[0m' edit_choice
        case $edit_choice in
            1) read -p $'\e[96mNew hostname: \e[0m' HOSTNAME; until validate_input name "$HOSTNAME"; do read -p $'\e[96mHostname: \e[0m' HOSTNAME; done ;;
            2) read -p $'\e[96mNew username: \e[0m' USERNAME; until validate_input username "$USERNAME"; do read -p $'\e[96mUsername: \e[0m' USERNAME; done ;;
            3) read -s -p $'\e[96mNew password: \e[0m' PASSWORD; echo ;;
            4) read -p $'\e[96mNew SSH port: \e[0m' SSH_PORT; until validate_input port "$SSH_PORT" && ! ss -tln | grep -q ":$SSH_PORT "; do read -p $'\e[96mPort: \e[0m' SSH_PORT; done ;;
            5) read -p $'\e[96mGUI? (y/n): \e[0m' gui; GUI_MODE=false; [[ $gui =~ ^[Yy]$ ]] && GUI_MODE=true ;;
            6) read -p $'\e[96mPort forwards: \e[0m' PORT_FORWARDS ;;
            7) read -p $'\e[96mRAM MB: \e[0m' MEMORY; until validate_input number "$MEMORY"; do read -p $'\e[96mRAM: \e[0m' MEMORY; done ;;
            8) read -p $'\e[96mCPUs: \e[0m' CPUS; until validate_input number "$CPUS"; do read -p $'\e[96mCPUs: \e[0m' CPUS; done ;;
            9) read -p $'\e[96mDisk size: \e[0m' DISK_SIZE; until validate_input size "$DISK_SIZE"; do read -p $'\e[96mSize: \e[0m' DISK_SIZE; done ;;
            0) break ;;
            *) error "Invalid" ;;
        esac
        [[ "$edit_choice" =~ ^[1-3]$ ]] && setup_vm_image
        save_vm_config
    done
}

resize_vm_disk() {
    local vm_name=$1
    load_vm_config "$vm_name" || return 1
    is_vm_running "$vm_name" && { error "Stop VM first"; return 1; }

    read -p $'\e[96mNew size (current: '$DISK_SIZE'): \e[0m' new_size
    new_size=${new_size:-$DISK_SIZE}
    until validate_input size "$new_size"; do read -p $'\e[96mSize: \e[0m' new_size; done

    qemu-img resize "$IMG_FILE" "$new_size" && DISK_SIZE="$new_size" && save_vm_config && success "Disk resized"
}

show_vm_performance() {
    local vm_name=$1
    load_vm_config "$vm_name" || return 1

    print_box_header "PERFORMANCE: $vm_name"
    if is_vm_running "$vm_name"; then
        local pid=$(pgrep -f "qemu-system.*$IMG_FILE")
        if [[ -n "$pid" ]]; then
            ps -p "$pid" -o pid,%cpu,%mem,rss,vsz,cmd --no-headers
            free -h
            df -h "$(dirname "$IMG_FILE")" || du -h "$IMG_FILE"
        fi
    else
        warning "VM not running"
        echo "RAM: $MEMORY MB | CPU: $CPUS | Disk: $DISK_SIZE"
    fi
    read -p $'\e[93mPress Enter...\e[0m' -r
}

fix_vm_issues() {
    local vm_name=$1
    load_vm_config "$vm_name" || return 1

    print_box_header "FIX ISSUES: $vm_name"
    echo "1) Remove lock files"
    echo "2) Recreate seed"
    echo "3) Recreate config"
    echo "4) Kill stuck QEMU"
    echo "0) Back"

    read -p $'\e[96mChoice: \e[0m' fix_choice
    case $fix_choice in
        1) rm -f "${IMG_FILE}.lock"*; success "Locks cleared" ;;
        2) rm -f "$SEED_FILE"; setup_vm_image ;;
        3) save_vm_config ;;
        4) pkill -9 -f "qemu-system.*$IMG_FILE" 2>/dev/null; success "Killed stuck processes" ;;
        0) return ;;
        *) error "Invalid" ;;
    esac
}

# Main Menu
main_menu() {
    while true; do
        display_header

        local vms=($(get_vm_list))
        local vm_count=${#vms[@]}

        if [ $vm_count -gt 0 ]; then
            progress "VMs ($vm_count):"
            for i in "${!vms[@]}"; do
                local status=" ðŸ”´ Stopped"
                is_vm_running "${vms[$i]}" && status=" ðŸŸ¢ Running"
                print_menu_option "$((i+1))" "${vms[$i]}" "$status"
            done
            echo
        fi

        print_box_header "CONTROL CENTER"

        print_menu_option "1" "Create New VM"
        [ $vm_count -gt 0 ] && print_menu_option "2" "Start VM"
        [ $vm_count -gt 0 ] && print_menu_option "3" "Stop VM"
        [ $vm_count -gt 0 ] && print_menu_option "4" "VM Info"
        [ $vm_count -gt 0 ] && print_menu_option "5" "Edit Config"
        [ $vm_count -gt 0 ] && print_menu_option "6" "Delete VM"
        [ $vm_count -gt 0 ] && print_menu_option "7" "Resize Disk"
        [ $vm_count -gt 0 ] && print_menu_option "8" "Performance"
        [ $vm_count -gt 0 ] && print_menu_option "9" "Fix Issues"
        print_menu_option "0" "Exit"

        read -p $'\e[93m\e[1mChoice: \e[0m' choice

        case $choice in
            1) create_new_vm ;;
            2|3|4|5|6|7|8|9)
                [ $vm_count -eq 0 ] && { warning "No VMs"; sleep 2; continue; }
                read -p $'\e[96mVM #: \e[0m' vm_num
                [[ "$vm_num" =~ ^[0-9]+$ ]] && [ "$vm_num" -ge 1 ] && [ "$vm_num" -le $vm_count ] || { error "Invalid"; sleep 2; continue; }
                local vm_name="${vms[$((vm_num-1))]}"
                case $choice in
                    2) start_vm "$vm_name" ;;
                    3) stop_vm "$vm_name" ;;
                    4) show_vm_info "$vm_name" ;;
                    5) edit_vm_config "$vm_name" ;;
                    6) delete_vm "$vm_name" ;;
                    7) resize_vm_disk "$vm_name" ;;
                    8) show_vm_performance "$vm_name" ;;
                    9) fix_vm_issues "$vm_name" ;;
                esac
                ;;
            0)
                clear
                echo -e "${DANGER}"
                cat << "EOF"
   _____   ____   ____   _____   ____   __  __ 
  / ____| |  _ \ |  _ \ |  __ \ |  _ \ |  \/  |
 | |  __  | |_) || |_) || |__) || |_) || \  / |
 | | |_ | |  _ < |  _ < |  ___/ |  _ < | |\/| |
 | |__| | | |_) || |_) || |     | |_) || |  | |
  \_____| |____/ |____/ |_|     |____/ |_|  |_|
                                               
EOF
                print_box_header "TERMINATED"
                echo -e "\n${WHITE}${BOLD}   Cloud VM Manager Closed${RESET}"
                echo -e "${YELLOW}${BOLD}         By MahimOp${RESET}\n"
                echo -e "${NEON_GREEN}${BOLD}Creator: MahimOp${RESET}"
                echo -e "${DIM}YouTube: @mahimxyz${RESET}"
                echo -e "${DIM}Discord: https://discord.gg/zkDNdPpArS${RESET}\n"
                echo -e "${GLOW}${BOLD}Power off complete. âœˆï¸${RESET}\n"
                exit 0
                ;;
            *) error "Invalid choice" ; sleep 2 ;;
        esac

        read -p $'\e[93mPress Enter to continue...\e[0m' -r
    done
}

# Cleanup
trap 'rm -f user-data meta-data 2>/dev/null' EXIT

# Start
check_dependencies
main_menu

#!/usr/bin/env bash

# ===================================================
#  CLOUD VM MANAGER - NEXT GEN ULTRA EDITION
#                     2025 Edition
# ===================================================
#  Original Creator: MahimOp
#  YouTube : https://www.youtube.com/@mahimxyz
#  Discord : https://discord.gg/zkDNdPpArS
#  Remastered with love by Grok
# ===================================================

set -euo pipefail

# Next-Gen Neon Color Theme (Fixed & Optimized)
RESET="\033[0m"
BOLD="\033[1m"
DIM="\033[2m"
UNDERLINE="\033[4m"

CYAN="\033[96m"
BLUE="\033[94m"
PURPLE="\033[95m"
GREEN="\033[92m"
YELLOW="\033[93m"
RED="\033[91m"
WHITE="\033[97m"

NEON_GREEN="\033[38;5;82m"
NEON_PURPLE="\033[38;5;165m"
NEON_BLUE="\033[38;5;75m"
NEON_CYAN="\033[38;5;51m"
DANGER="\033[38;5;196m"

# Paths
VM_DIR="${VM_DIR:-$HOME/vms}"
mkdir -p "$VM_DIR"

# Supported OS Images (Now with Debian 11)
declare -A OS_OPTIONS=(
    ["Ubuntu 24.04 LTS"]="ubuntu|noble|https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-amd64.img|ubuntu24|ubuntu|ubuntu"
    ["Ubuntu 22.04 LTS"]="ubuntu|jammy|https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img|ubuntu22|ubuntu|ubuntu"
    ["Debian 12 Bookworm"]="debian|bookworm|https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2|debian12|debian|debian"
    ["Debian 11 Bullseye"]="debian|bullseye|https://cloud.debian.org/images/cloud/bullseye/latest/debian-11-generic-amd64.qcow2|debian11|debian|debian"
    ["Debian 13 Trixie (Daily)"]="debian|trixie|https://cloud.debian.org/images/cloud/trixie/daily/latest/debian-13-generic-amd64-daily.qcow2|debian13|debian|debian"
    ["AlmaLinux 9"]="almalinux|9|https://repo.almalinux.org/almalinux/9/cloud/x86_64/images/AlmaLinux-9-GenericCloud-latest.x86_64.qcow2|almalinux9|alma|alma"
    ["Rocky Linux 9"]="rockylinux|9|https://download.rockylinux.org/pub/rocky/9/images/x86_64/Rocky-9-GenericCloud-latest.x86_64.qcow2|rocky9|rocky|rocky"
)

# Masterpiece Header
display_header() {
    clear
    echo -e "${NEON_BLUE}${BOLD}"
    cat << 'EOF'
   _____ _     ___  _   _  ____    __     __ __  __ 
  / ____| |   / _ \| \ | |/ __ \   \ \   / /|  \/  |
 | |    | |  | | | |  \| | |  | |   \ \_/ / | \  / |
 | |    | |  | | | | . ` | |  | |    \   /  | |\/| |
 | |____| |__| |_| | |\  | |__| |     | |   | |  | |
  \_____|_____\___/|_| \_|\____/      |_|   |_|  |_|
                                                    
     __     __ __  __   ___   _   _   ___   ____  
     \ \   / /|  \/  | / _ \ | \ | | / _ \ |  _ \ 
      \ \_/ / | \  / || | | ||  \| || | | || |_) |
       \   /  | |\/| || |_| || . ` || |_| ||  _ < 
        | |   | |  | | \___/ | |\  | \___/ | |_) |
        |_|   |_|  |_|     |_|_| \_|     |_|____/ 
                                                  
EOF
    echo -e "${RESET}${NEON_PURPLE}${BOLD}               NEXT GEN ULTRA EDITION â€¢ 2025${RESET}"
    echo -e "${NEON_CYAN}           Advanced â€¢ Secure â€¢ Lightning Fast Cloud VMs${RESET}"
    echo -e "${DIM}       Original Creator: ${BOLD}MahimOp${RESET} â€¢ YouTube: @mahimxyz â€¢ Discord: zkDNdPpArS${RESET}"
    echo -e "${NEON_BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}\n"
}

# Status Indicators
progress() { echo -e "${NEON_GREEN}${BOLD}âžœ $1${RESET}"; }
success() { echo -e "${GREEN}${BOLD}âœ“ $1${RESET}"; }
warning() { echo -e "${YELLOW}${BOLD}âš  $1${RESET}"; }
error() { echo -e "${RED}${BOLD}âœ— $1${RESET}"; }

# UI Elements
box_header() {
    local title="$1"
    echo -e "${NEON_PURPLE}${BOLD}"
    printf 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n'
    printf 'â•‘ %-58s â•‘\n' " $title "
    printf 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'
    echo -e "${RESET}"
}

menu_item() {
    local num="$1"
    local text="$2"
    local status="${3:-}"
    printf "${NEON_BLUE}  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${RESET}\n"
    printf "${NEON_BLUE}  â”‚${RESET} ${WHITE}${BOLD}[${NEON_GREEN}%2s${WHITE}]${RESET} ${CYAN}%-40s${status} ${NEON_BLUE}â”‚${RESET}\n" "$num" "$text"
    printf "${NEON_BLUE}  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${RESET}\n"
}

# Dependency Check
check_dependencies() {
    local deps=("qemu-system-x86_64" "wget" "cloud-localds" "qemu-img" "lsof")
    local missing=()
    for dep in "${deps[@]}"; do
        command -v "$dep" &>/dev/null || missing+=("$dep")
    done
    if [ ${#missing[@]} -ne 0 ]; then
        error "Missing dependencies: ${missing[*]}"
        warning "Install: sudo apt install qemu-system cloud-image-utils wget lsof"
        exit 1
    fi
}

# Core Helpers
get_vm_list() { find "$VM_DIR" -name "*.conf" -exec basename {} .conf \; 2>/dev/null | sort; }

is_vm_running() {
    local vm_name="$1"
    pgrep -f "qemu-system.*$vm_name" >/dev/null && return 0
    load_vm_config "$vm_name" 2>/dev/null && [[ -n "${IMG_FILE:-}" ]] && pgrep -f "qemu-system.*${IMG_FILE}" >/dev/null && return 0
    return 1
}

load_vm_config() {
    local file="$VM_DIR/$1.conf"
    [[ -f "$file" ]] && source "$file" && return 0 || return 1
}

check_image_lock() {
    local img="$1" vm="$2"
    if lsof "$img" 2>/dev/null | grep -q qemu-system; then
        warning "Image in use by another process"
        return 1
    fi
    local lock="${img}.lock"
    if [[ -f "$lock" ]] && ! find "$lock" -mmin +5 &>/dev/null; then
        return 1
    fi
    return 0
}

validate_input() {
    local type="$1" value="$2"
    case "$type" in
        number) [[ "$value" =~ ^[0-9]+$ ]] || return 1 ;;
        size) [[ "$value" =~ ^[0-9]+[GMgm]$ ]] || return 1 ;;
        port) [[ "$value" =~ ^[0-9]+$ ]] && ((23 <= value && value <= 65535)) || return 1 ;;
        name) [[ "$value" =~ ^[a-zA-Z0-9_-]+$ ]] || return 1 ;;
        username) [[ "$value" =~ ^[a-z_][a-z0-9_-]*$ ]] || return 1 ;;
    esac
    return 0
}

save_vm_config() {
    cat > "$VM_DIR/$VM_NAME.conf" <<EOF
VM_NAME="$VM_NAME"
OS_TYPE="$OS_TYPE"
CODENAME="$CODENAME"
IMG_URL="$IMG_URL"
HOSTNAME="$HOSTNAME"
USERNAME="$USERNAME"
PASSWORD="$PASSWORD"
DISK_SIZE="$DISK_SIZE"
MEMORY="$MEMORY"
CPUS="$CPUS"
SSH_PORT="$SSH_PORT"
GUI_MODE="$GUI_MODE"
PORT_FORWARDS="$PORT_FORWARDS"
IMG_FILE="$IMG_FILE"
SEED_FILE="$SEED_FILE"
CREATED="$(date)"
EOF
    success "Config saved"
}

setup_vm_image() {
    progress "Setting up image..."
    mkdir -p "$VM_DIR"

    if [[ ! -f "$IMG_FILE" ]]; then
        progress "Downloading $OS_TYPE image..."
        wget --progress=bar:force:noscroll "$IMG_URL" -O "$IMG_FILE"
    fi

    qemu-img resize "$IMG_FILE" "$DISK_SIZE" &>/dev/null || true

    cat > user-data <<EOF
#cloud-config
hostname: $HOSTNAME
ssh_pwauth: true
disable_root: false
users:
  - name: $USERNAME
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash
    passwd: $(openssl passwd -6 "$PASSWORD")
chpasswd:
  list: |
    root:$PASSWORD
    $USERNAME:$PASSWORD
  expire: false
EOF

    echo "instance-id: iid-$VM_NAME" > meta-data
    echo "local-hostname: $HOSTNAME" >> meta-data

    cloud-localds "$SEED_FILE" user-data meta-data
    success "Ready for launch"
}

create_new_vm() {
    display_header
    box_header "CREATE NEW VM"

    local os_list=("${!OS_OPTIONS[@]}")
    local count=${#os_list[@]}
    for ((i=0; i<count; i++)); do
        echo -e " ${NEON_GREEN}$((i+1))${RESET} ${os_list[$i]}"
    done

    local choice
    while :; do
        printf "${CYAN}Select OS [1-%s]: ${RESET}" "$count"
        read choice
        [[ "$choice" =~ ^[0-9]+$ ]] && ((1 <= choice && choice <= count)) && break
        error "Invalid choice"
    done

    local sel="${os_list[$((choice-1))]}"
    IFS='|' read -r OS_TYPE CODENAME IMG_URL DEF_HOST DEF_USER DEF_PASS <<< "${OS_OPTIONS[$sel]}"

    printf "${CYAN}VM Name [%s]: ${RESET}" "$DEF_HOST"
    read VM_NAME; VM_NAME=${VM_NAME:-$DEF_HOST}
    until validate_input name "$VM_NAME" && [[ ! -f "$VM_DIR/$VM_NAME.conf" ]]; do
        error "Invalid or exists"
        printf "${CYAN}Name: ${RESET}"
        read VM_NAME
    done

    printf "${CYAN}Hostname [%s]: ${RESET}" "$VM_NAME"
    read HOSTNAME; HOSTNAME=${HOSTNAME:-$VM_NAME}

    printf "${CYAN}Username [%s]: ${RESET}" "$DEF_USER"
    read USERNAME; USERNAME=${USERNAME:-$DEF_USER}

    printf "${CYAN}Password [auto]: ${RESET}"
    read -s PASSWORD; echo
    PASSWORD=${PASSWORD:-$DEF_PASS}

    printf "${CYAN}Disk [20G]: ${RESET}"
    read DISK_SIZE; DISK_SIZE=${DISK_SIZE:-20G}
    until validate_input size "$DISK_SIZE"; do
        printf "${CYAN}Disk: ${RESET}"
        read DISK_SIZE
    done

    printf "${CYAN}RAM MB [2048]: ${RESET}"
    read MEMORY; MEMORY=${MEMORY:-2048}
    until validate_input number "$MEMORY"; do
        printf "${CYAN}RAM: ${RESET}"
        read MEMORY
    done

    printf "${CYAN}CPUs [2]: ${RESET}"
    read CPUS; CPUS=${CPUS:-2}
    until validate_input number "$CPUS"; do
        printf "${CYAN}CPUs: ${RESET}"
        read CPUS
    done

    printf "${CYAN}SSH Port [2222]: ${RESET}"
    read SSH_PORT; SSH_PORT=${SSH_PORT:-2222}
    until validate_input port "$SSH_PORT" && ! ss -tln | grep -q ":$SSH_PORT "; do
        error "Port invalid or in use"
        printf "${CYAN}Port: ${RESET}"
        read SSH_PORT
    done

    printf "${CYAN}GUI? (y/n) [n]: ${RESET}"
    read gui; GUI_MODE=false; [[ "$gui" =~ ^[Yy]$ ]] && GUI_MODE=true

    printf "${CYAN}Extra forwards: ${RESET}"
    read PORT_FORWARDS

    IMG_FILE="$VM_DIR/$VM_NAME.img"
    SEED_FILE="$VM_DIR/$VM_NAME-seed.iso"

    setup_vm_image
    save_vm_config
    success "VM '$VM_NAME' created!"
    progress "Connect: ssh -p $SSH_PORT $USERNAME@localhost"
}

start_vm() {
    local vm="$1"
    load_vm_config "$vm"

    check_image_lock "$IMG_FILE" "$vm" || { error "Image locked"; return; }
    is_vm_running "$vm" && { warning "Already running"; return; }

    local cmd=(
        qemu-system-x86_64 -enable-kvm -m "$MEMORY"M -smp "$CPUS" -cpu host
        -drive file="$IMG_FILE",format=qcow2,if=virtio,cache=writeback
        -drive file="$SEED_FILE",format=raw,if=virtio
        -boot order=c
        -device virtio-net-pci,netdev=n0
        -netdev user,id=n0,hostfwd=tcp::"$SSH_PORT"-:22
        -device virtio-balloon-pci
        -object rng-random,id=rng0,filename=/dev/urandom
        -device virtio-rng-pci,rng=rng0
    )

    if [[ -n "$PORT_FORWARDS" ]]; then
        IFS=',' read -ra fw <<< "$PORT_FORWARDS"
        local id=1
        for p in "${fw[@]}"; do
            IFS=':' read -r h g <<< "$p"
            cmd+=(-netdev user,id=n$id,hostfwd=tcp::"$h"-:"$g" -device virtio-net-pci,netdev=n$id)
            ((id++))
        done
    fi

    [[ "$GUI_MODE" == true ]] && cmd+=(-vga virtio -display gtk,gl=on) || cmd+=(-nographic)

    progress "Launching $vm..."
    progress "SSH â†’ port $SSH_PORT"
    "${cmd[@]}"
    progress "VM terminated"
}

stop_vm() {
    local vm="$1"
    load_vm_config "$vm"
    is_vm_running "$vm" || { warning "Not running"; return; }
    progress "Stopping $vm..."
    pkill -f "qemu-system.*$IMG_FILE" || pkill -9 -f "qemu-system.*$IMG_FILE" || true
    rm -f "${IMG_FILE}.lock" 2>/dev/null
    success "Stopped"
}

delete_vm() {
    local vm="$1"
    load_vm_config "$vm"
    warning "PERMANENT DELETE '$vm'?"
    read -p "Type YES: " c
    [[ "$c" == "YES" ]] || { progress "Cancelled"; return; }
    is_vm_running "$vm" && stop_vm "$vm"
    rm -f "$IMG_FILE" "$SEED_FILE" "$VM_DIR/$vm.conf" "${IMG_FILE}.lock"
    success "Deleted"
}

show_vm_info() {
    local vm="$1"
    load_vm_config "$vm"
    box_header "INFO: $vm"
    echo -e "${WHITE}OS:${RESET} $OS_TYPE $CODENAME"
    echo -e "${WHITE}Host:${RESET} $HOSTNAME â€¢ ${WHITE}User:${RESET} $USERNAME"
    echo -e "${WHITE}SSH:${RESET} ssh -p $SSH_PORT $USERNAME@localhost"
    echo -e "${WHITE}Resources:${RESET} $MEMORY MB RAM â€¢ $CPUS CPU â€¢ $DISK_SIZE Disk"
    echo -e "${WHITE}GUI:${RESET} $GUI_MODE â€¢ ${WHITE}Forwards:${RESET} ${PORT_FORWARDS:-None}"
    echo -e "${WHITE}Status:${RESET} $(is_vm_running "$vm" && echo "ðŸŸ¢ Running" || echo "ðŸ”´ Stopped")"
    read -p $'\e[93mPress Enter... \e[0m' -r
}

edit_vm_config() {
    local vm="$1"
    load_vm_config "$vm"
    while :; do
        box_header "EDIT: $vm"
        echo "1) Hostname     [$HOSTNAME]"
        echo "2) Username     [$USERNAME]"
        echo "3) Password     [â€¢â€¢â€¢â€¢â€¢â€¢â€¢]"
        echo "4) SSH Port     [$SSH_PORT]"
        echo "5) GUI Mode     [$GUI_MODE]"
        echo "6) Forwards     [$PORT_FORWARDS]"
        echo "7) RAM          [$MEMORY MB]"
        echo "8) CPUs         [$CPUS]"
        echo "9) Disk         [$DISK_SIZE]"
        echo "0) Back"
        read -p "Choice: " c
        case "$c" in
            1) printf "${CYAN}Hostname: ${RESET}"; read HOSTNAME ;;
            2) printf "${CYAN}Username: ${RESET}"; read USERNAME ;;
            3) printf "${CYAN}Password: ${RESET}"; read -s PASSWORD; echo ;;
            4) printf "${CYAN}Port: ${RESET}"; read SSH_PORT ;;
            5) printf "${CYAN}GUI (y/n): ${RESET}"; read g; GUI_MODE=false; [[ "$g" =~ ^[Yy]$ ]] && GUI_MODE=true ;;
            6) printf "${CYAN}Forwards: ${RESET}"; read PORT_FORWARDS ;;
            7) printf "${CYAN}RAM MB: ${RESET}"; read MEMORY ;;
            8) printf "${CYAN}CPUs: ${RESET}"; read CPUS ;;
            9) printf "${CYAN}Disk: ${RESET}"; read DISK_SIZE ;;
            0) return ;;
        esac
        [[ "$c" =~ ^[1-3]$ ]] && setup_vm_image
        save_vm_config
    done
}

resize_vm_disk() {
    local vm="$1"
    load_vm_config "$vm"
    is_vm_running "$vm" && { error "Stop first"; return; }
    printf "${CYAN}New size [%s]: ${RESET}" "$DISK_SIZE"
    read size; size=${size:-$DISK_SIZE}
    qemu-img resize "$IMG_FILE" "$size" && DISK_SIZE="$size" && save_vm_config && success "Resized to $size"
}

show_vm_performance() {
    local vm="$1"
    load_vm_config "$vm"
    box_header "PERFORMANCE: $vm"
    if is_vm_running "$vm"; then
        local pid=$(pgrep -f "qemu-system.*$IMG_FILE")
        [[ -n "$pid" ]] && ps -p "$pid" -o pid,%cpu,%mem,rss,vsz,cmd --no-headers
        free -h
        df -h "$(dirname "$IMG_FILE")"
    else
        warning "Not running"
        echo "Config: $MEMORY MB RAM â€¢ $CPUS CPU â€¢ $DISK_SIZE Disk"
    fi
    read -p "Press Enter..."
}

fix_vm_issues() {
    local vm="$1"
    load_vm_config "$vm"
    box_header "FIX: $vm"
    echo "1) Clear locks"
    echo "2) Rebuild seed"
    echo "3) Rebuild config"
    echo "4) Kill stuck QEMU"
    echo "0) Back"
    read -p "Choice: " c
    case "$c" in
        1) rm -f "${IMG_FILE}.lock"*; success "Cleared" ;;
        2) rm -f "$SEED_FILE"; setup_vm_image ;;
        3) save_vm_config ;;
        4) pkill -9 -f "qemu-system.*$IMG_FILE" 2>/dev/null; success "Killed" ;;
        0) return ;;
    esac
}

# Main Loop
main_menu() {
    while :; do
        display_header

        local vms=($(get_vm_list))
        local n=${#vms[@]}

        if (( n > 0 )); then
            progress "Virtual Machines ($n):"
            for i in "${!vms[@]}"; do
                menu_item "$((i+1))" "${vms[$i]}" "$(is_vm_running "${vms[$i]}" && echo " ðŸŸ¢" || echo " ðŸ”´")"
            done
            echo
        fi

        box_header "CONTROL CENTER"

        menu_item "1" "Create New VM"
        (( n > 0 )) && menu_item "2" "Start VM"
        (( n > 0 )) && menu_item "3" "Stop VM"
        (( n > 0 )) && menu_item "4" "Info"
        (( n > 0 )) && menu_item "5" "Edit"
        (( n > 0 )) && menu_item "6" "Delete"
        (( n > 0 )) && menu_item "7" "Resize Disk"
        (( n > 0 )) && menu_item "8" "Performance"
        (( n > 0 )) && menu_item "9" "Fix Issues"
        menu_item "0" "Exit"

        printf "${NEON_CYAN}${BOLD}Choice: ${RESET}"
        read choice

        case "$choice" in
            1) create_new_vm ;;
            2|3|4|5|6|7|8|9)
                (( n == 0 )) && { warning "No VMs"; sleep 2; continue; }
                printf "${NEON_CYAN}VM number: ${RESET}"
                read num
                [[ "$num" =~ ^[0-9]+$ ]] && (( 1 <= num && num <= n )) || { error "Invalid"; sleep 2; continue; }
                vm="${vms[$((num-1))]}"
                case "$choice" in
                    2) start_vm "$vm" ;;
                    3) stop_vm "$vm" ;;
                    4) show_vm_info "$vm" ;;
                    5) edit_vm_config "$vm" ;;
                    6) delete_vm "$vm" ;;
                    7) resize_vm_disk "$vm" ;;
                    8) show_vm_performance "$vm" ;;
                    9) fix_vm_issues "$vm" ;;
                esac
                ;;
            0)
                clear
                echo -e "${DANGER}${BOLD}"
                cat << 'EOF'
   _____   ____   ____   _____   ____    _____   _   _   _____   ____  
  / ____| / __ \ |  _ \ |  __ \ |___ \  | ____| | | | | / ____| |___ \ 
 | |  __ | |  | || |_) || |__) |  __) | | |__   | | | || |  __   __) |
 | | |_ || |  | ||  _ < |  ___/  |__ <  |___ \  | | | || | |_ | |__ < 
 | |__| || |__| || |_) || |      ___) |  ___) | | |_| || |__| | ___) |
  \_____| \____/ |____/ |_|     |____/  |____/   \___/  \_____| |____/ 
                                                                      
EOF
                echo -e "${RESET}"
                box_header "SESSION TERMINATED"
                echo -e "\n${WHITE}${BOLD}   Cloud VM Manager â€¢ Powered Off${RESET}"
                echo -e "${YELLOW}${BOLD}           Created by MahimOp${RESET}\n"
                echo -e "${NEON_GREEN}${BOLD}YouTube:${RESET} @mahimxyz"
                echo -e "${NEON_GREEN}${BOLD}Discord:${RESET} zkDNdPpArS\n"
                echo -e "${NEON_CYAN}${BOLD}See you in the cloud. âœˆï¸${RESET}\n"
                exit 0
                ;;
            *) error "Invalid choice" ; sleep 2 ;;
        esac

        read -p $'\e[93mPress Enter to continue...\e[0m' -r
    done
}

# Cleanup & Start
trap 'rm -f user-data meta-data 2>/dev/null' EXIT
check_dependencies
main_menu

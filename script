#!/bin/bash
set -euo pipefail

# ========================================================================
# Enhanced Multi-VM Manager (QEMU/KVM & Cloud-Init)
# ========================================================================
# Base Code Credit: HOPINGBOYZ & EDIT BY NOBITA
# Completed & Remastered by Gemini
# Used for safe, authorized, educational, and testing purposes only.

# --- Global Configuration & Variables ---
VM_DIR="$HOME/qemu_vms"

# OS_OPTIONS: OS_NAME="OS_TYPE|CODENAME|IMG_URL|DEFAULT_HOSTNAME|DEFAULT_USERNAME|DEFAULT_PASSWORD"
declare -A OS_OPTIONS=(
    ["Ubuntu 22.04 LTS (Jammy)"]="ubuntu|jammy|https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img|ubuntu-vm|ubuntu|ubuntu"
    ["Debian 12 (Bookworm)"]="debian|bookworm|https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2|debian-vm|debian|debian"
    ["Alpine Linux Edge"]="alpine|edge|https://dl-cdn.alpinelinux.org/alpine/latest-stable/releases/x86_64/alpine-virt-3.19.1-x86_64.iso|alpine-vm|alpine|alpine"
)

# --- Utility Functions ---

# Function to display header
display_header() {
    clear
    cat << "EOF"
========================================================================
                       _ _     _                 
                      | (_)   | |                
                      | |_ ___| |__  _ __  _   _ 
                  _   | | / __| '_ \| '_ \| | | |
                 | |__| | \__ \ | | | | | | |_| |
                  \____/|_|___/_| |_|_| |_|\__,_| 
                                                                  
        QEMU/KVM VIRTUAL MACHINE MANAGER | HOPINGBOYZ & NOBITA
========================================================================
EOF
    echo
}

# Function to display colored output with emojis
print_status() {
    local type=$1
    local message=$2
    
    # ANSI Color Codes: 31=Red, 32=Green, 33=Yellow, 34=Blue, 36=Cyan, 0=Reset
    case $type in
        "INFO") echo -e "\033[1;34mðŸ“‹ [INFO]\033[0m $message" ;;
        "WARN") echo -e "\033[1;33mâš ï¸  [WARN]\033[0m $message" ;;
        "ERROR") echo -e "\033[1;31mâŒ [ERROR]\033[0m $message" ;;
        "SUCCESS") echo -e "\033[1;32mâœ… [SUCCESS]\033[0m $message" ;;
        "INPUT") echo -e "\033[1;36mðŸŽ¯ [INPUT]\033[0m $message" ;;
        *) echo "[$type] $message" ;;
    esac
}

# Function to check if image file is locked
check_image_lock() {
    local img_file=$1
    local vm_name=$2
    
    # Check if QEMU is already using this image
    if lsof "$img_file" 2>/dev/null | grep -q qemu-system; then
        print_status "WARN" "ðŸ”’ Image file $img_file is already in use by another QEMU process"
        
        local pid=$(lsof "$img_file" 2>/dev/null | grep qemu-system | awk '{print $2}' | head -1)
        if [[ -n "$pid" ]]; then
            print_status "INFO" "ðŸ” Process ID using the image: $pid"
            
            if ps -p "$pid" -o cmd= | grep -q "$vm_name"; then
                print_status "INFO" "ðŸ¤” This appears to be the same VM already running"
                read -p "$(print_status "INPUT" "ðŸ”„ Kill existing process and restart? (y/N): ")" kill_choice
                if [[ "$kill_choice" =~ ^[Yy]$ ]]; then
                    kill "$pid" 2>/dev/null
                    sleep 2
                    if kill -0 "$pid" 2>/dev/null; then
                        kill -9 "$pid" 2>/dev/null
                        print_status "WARN" "âš ï¸  Forcefully terminated process $pid"
                    fi
                    return 0
                else
                    return 1
                fi
            else
                print_status "ERROR" "ðŸš« Another QEMU instance is using this image"
                return 1
            fi
        fi
        return 1
    fi
    
    # Check for QEMU lock files
    local lock_file="${img_file}.lock"
    if [[ -f "$lock_file" ]]; then
        print_status "WARN" "ðŸ”’ Lock file found: $lock_file"
        
        if [[ $(find "$lock_file" -mmin +5 2>/dev/null) ]]; then
            print_status "WARN" "â° Lock file appears stale (older than 5 minutes)"
            read -p "$(print_status "INPUT" "ðŸ—‘ï¸  Remove stale lock file? (y/N): ")" remove_lock
            if [[ "$remove_lock" =~ ^[Yy]$ ]]; then
                rm -f "$lock_file"
                print_status "SUCCESS" "âœ… Removed stale lock file"
                return 0
            else
                return 1
            fi
        fi
        return 1
    fi
    return 0
}

# Function to validate input
validate_input() {
    local type=$1
    local value=$2
    
    case $type in
        "number")
            if ! [[ "$value" =~ ^[0-9]+$ ]]; then
                print_status "ERROR" "âŒ Must be a number"
                return 1
            fi
            ;;
        "size")
            if ! [[ "$value" =~ ^[0-9]+[GgMm]$ ]]; then
                print_status "ERROR" "âŒ Must be a size with unit (e.g., 100G, 512M)"
                return 1
            fi
            ;;
        "port")
            if ! [[ "$value" =~ ^[0-9]+$ ]] || [ "$value" -lt 1024 ] || [ "$value" -gt 65535 ]; then
                print_status "ERROR" "âŒ Must be a valid port number (1024-65535)"
                return 1
            fi
            ;;
        "name")
            if ! [[ "$value" =~ ^[a-zA-Z0-9_-]+$ ]]; then
                print_status "ERROR" "âŒ Name can only contain letters, numbers, hyphens, and underscores"
                return 1
            fi
            ;;
        "username")
            if ! [[ "$value" =~ ^[a-z_][a-z0-9_-]*$ ]]; then
                print_status "ERROR" "âŒ Username must start with a letter/underscore and contain only letters, numbers, hyphens, and underscores"
                return 1
            fi
            ;;
        "password")
            if [ ${#value} -lt 6 ]; then
                print_status "ERROR" "âŒ Password must be at least 6 characters long"
                return 1
            fi
            ;;
        "forward")
            # Format: HOST_PORT:GUEST_PORT
            if ! [[ "$value" =~ ^[0-9]+:[0-9]+$ ]]; then
                print_status "ERROR" "âŒ Must be in format HOST_PORT:GUEST_PORT (e.g., 8080:80)"
                return 1
            fi
            ;;
    esac
    return 0
}

# Function to check dependencies
check_dependencies() {
    local deps=("qemu-system-x86_64" "wget" "cloud-localds" "qemu-img" "lsof" "openssl")
    local missing_deps=()
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing_deps+=("$dep")
        fi
    done
    
    if [ ${#missing_deps[@]} -ne 0 ]; then
        print_status "ERROR" "ðŸ”§ Missing dependencies: ${missing_deps[*]}"
        print_status "INFO" "ðŸ’¡ On Ubuntu/Debian, try: sudo apt install qemu-system cloud-image-utils wget lsof openssl"
        exit 1
    fi
}

# Function to cleanup temporary files
cleanup() {
    if [ -f "user-data" ]; then rm -f "user-data"; fi
    if [ -f "meta-data" ]; then rm -f "meta-data"; fi
}

# Function to get all VM configurations
get_vm_list() {
    mkdir -p "$VM_DIR" 2>/dev/null
    find "$VM_DIR" -maxdepth 1 -name "*.conf" -exec basename {} .conf \; 2>/dev/null | sort
}

# Function to load VM configuration
load_vm_config() {
    local vm_name=$1
    local config_file="$VM_DIR/$vm_name.conf"
    
    if [[ -f "$config_file" ]]; then
        # Clear previous variables
        unset VM_NAME OS_TYPE CODENAME IMG_URL HOSTNAME USERNAME PASSWORD
        unset DISK_SIZE MEMORY CPUS SSH_PORT GUI_MODE PORT_FORWARDS IMG_FILE SEED_FILE CREATED
        
        # Source the config file to load variables
        source "$config_file"
        return 0
    else
        # print_status "ERROR" "ðŸ“‚ Configuration for VM '$vm_name' not found"
        return 1
    fi
}

# Function to save VM configuration
save_vm_config() {
    local config_file="$VM_DIR/$VM_NAME.conf"
    
    cat > "$config_file" <<EOF
VM_NAME="$VM_NAME"
OS_TYPE="$OS_TYPE"
CODENAME="$CODENAME"
IMG_URL="$IMG_URL"
HOSTNAME="$HOSTNAME"
USERNAME="$USERNAME"
PASSWORD="$PASSWORD"
DISK_SIZE="$DISK_SIZE"
MEMORY="$MEMORY"
CPUS="$CPUS"
SSH_PORT="$SSH_PORT"
GUI_MODE="$GUI_MODE"
PORT_FORWARDS="$PORT_FORWARDS"
IMG_FILE="$IMG_FILE"
SEED_FILE="$SEED_FILE"
CREATED="$CREATED"
EOF
    
    print_status "SUCCESS" "ðŸ’¾ Configuration saved to $config_file"
}

# Function to setup VM image (Download, Resize, Cloud-Init)
setup_vm_image() {
    print_status "INFO" "ðŸ“¥ Downloading and preparing image..."
    
    mkdir -p "$VM_DIR"
    
    # 1. Check/Download Image
    if [[ -f "$IMG_FILE" ]]; then
        print_status "INFO" "âœ… Image file already exists. Skipping download."
    else
        print_status "INFO" "ðŸŒ Downloading image from $IMG_URL..."
        if ! wget --progress=bar:force "$IMG_URL" -O "$IMG_FILE.tmp"; then
            print_status "ERROR" "âŒ Failed to download image from $IMG_URL"
            exit 1
        fi
        mv "$IMG_FILE.tmp" "$IMG_FILE"
    fi
    
    # 2. Resize the disk image
    print_status "INFO" "ðŸ’¾ Resizing disk image to $DISK_SIZE..."
    if ! qemu-img resize "$IMG_FILE" "$DISK_SIZE" 2>/dev/null; then
        print_status "WARN" "âš ï¸  Failed to directly resize image. Creating a new Cow2 image based on it..."
        local temp_new_img="$VM_DIR/$VM_NAME-new.qcow2"
        rm -f "$temp_new_img" 2>/dev/null
        if qemu-img create -f qcow2 -b "$IMG_FILE" "$temp_new_img" "$DISK_SIZE" 2>/dev/null; then
            mv "$IMG_FILE" "$VM_DIR/$VM_NAME-base.img" # Rename base image
            IMG_FILE="$temp_new_img"                   # Use the new cow image
            print_status "SUCCESS" "âœ… Created Cow2 overlay image: $IMG_FILE"
        else
            print_status "ERROR" "âŒ Fatal: Could not resize or create Cow2 image. Disk setup failed."
            exit 1
        fi
    fi

    # 3. cloud-init configuration files
    local HASHED_PASSWORD=$(openssl passwd -6 "$PASSWORD" 2>/dev/null | tr -d '\n')
    
    cat > user-data <<EOF
#cloud-config
hostname: $HOSTNAME
ssh_pwauth: true
disable_root: false
users:
  - name: $USERNAME
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash
    password: $HASHED_PASSWORD
chpasswd:
  list: |
    root:$PASSWORD
    $USERNAME:$PASSWORD
  expire: false
EOF

    cat > meta-data <<EOF
instance-id: iid-$VM_NAME
local-hostname: $HOSTNAME
EOF

    # 4. Create seed image
    rm -f "$SEED_FILE" 2>/dev/null
    if ! cloud-localds "$SEED_FILE" user-data meta-data; then
        print_status "ERROR" "âŒ Failed to create cloud-init seed image"
        exit 1
    fi
    
    print_status "SUCCESS" "ðŸŽ‰ VM '$VM_NAME' image prepared successfully."
}

# Function to create new VM
create_new_vm() {
    print_status "INFO" "ðŸ†• Starting New VM Creation Wizard"
    
    # --- 1. OS Selection ---
    print_status "INFO" "ðŸŒ Select an OS to set up:"
    local os_options=()
    local i=1
    for os in "${!OS_OPTIONS[@]}"; do
        echo "  $i) $os"
        os_options[$i]="$os"
        ((i++))
    done
    
    local choice
    while true; do
        read -p "$(print_status "INPUT" "ðŸŽ¯ Enter your choice (1-$((i-1))): ")" choice
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -lt "$i" ]; then
            local os="${os_options[$choice]}"
            # shellcheck disable=SC2206
            IFS='|' read -r OS_TYPE CODENAME IMG_URL HOSTNAME USERNAME PASSWORD <<< "${OS_OPTIONS[$os]}"
            break
        else
            print_status "ERROR" "âŒ Invalid selection. Try again."
        fi
    done
    
    # --- 2. VM Name ---
    while true; do
        read -p "$(print_status "INPUT" "ðŸ·ï¸  Enter VM name (default: $HOSTNAME): ")" VM_NAME_INPUT
        VM_NAME="${VM_NAME_INPUT:-$HOSTNAME}"
        if validate_input "name" "$VM_NAME"; then
            if [[ -f "$VM_DIR/$VM_NAME.conf" ]]; then
                print_status "ERROR" "âš ï¸  VM with name '$VM_NAME' already exists"
            else
                break
            fi
        fi
    done
    HOSTNAME="$VM_NAME" # Default hostname is the VM name

    # --- 3. User Credentials ---
    print_status "INFO" "ðŸ‘¤ Default user: $USERNAME | Default pass: $PASSWORD"
    read -p "$(print_status "INPUT" "ðŸŽ¯ Use default user/pass? (Y/n): ")" use_default_creds
    if [[ ! "$use_default_creds" =~ ^[Nn]$ ]]; then
        # Default credentials accepted
        : 
    else
        while true; do
            read -p "$(print_status "INPUT" "ðŸ‘¤ Enter custom username: ")" USERNAME
            if validate_input "username" "$USERNAME"; then
                break
            fi
        done
        while true; do
            read -p "$(print_status "INPUT" "ðŸ”‘ Enter custom password (min 6 chars): ")" PASSWORD
            if validate_input "password" "$PASSWORD"; then
                break
            fi
        done
    fi

    # --- 4. Resources and Networking ---
    while true; do
        read -p "$(print_status "INPUT" "ðŸ’¾ Enter Disk Size (e.g., 20G, default: 20G): ")" DISK_SIZE
        DISK_SIZE="${DISK_SIZE:-20G}"
        if validate_input "size" "$DISK_SIZE"; then
            break
        fi
    done
    while true; do
        read -p "$(print_status "INPUT" "ðŸ§  Enter Memory in MB (e.g., 2048, default: 2048): ")" MEMORY
        MEMORY="${MEMORY:-2048}"
        if validate_input "number" "$MEMORY" && [ "$MEMORY" -ge 512 ]; then
            break
        fi
    done
    while true; do
        read -p "$(print_status "INPUT" "âš¡ Enter CPU Count (default: 2): ")" CPUS
        CPUS="${CPUS:-2}"
        if validate_input "number" "$CPUS" && [ "$CPUS" -ge 1 ]; then
            break
        fi
    done
    while true; do
        read -p "$(print_status "INPUT" "ðŸ”Œ Enter Host SSH Port (e.g., 2222, default: 2222): ")" SSH_PORT
        SSH_PORT="${SSH_PORT:-2222}"
        if validate_input "port" "$SSH_PORT"; then
            break
        fi
    done
    
    read -p "$(print_status "INPUT" "ðŸ–¥ï¸  Enable graphical console (VNC/GTK)? (y/N): ")" gui_choice
    GUI_MODE=false
    if [[ "$gui_choice" =~ ^[Yy]$ ]]; then
        GUI_MODE=true
    fi
    
    # --- 5. Final Setup ---
    IMG_FILE="$VM_DIR/$VM_NAME.img"
    SEED_FILE="$VM_DIR/$VM_NAME-seed.iso"
    CREATED="$(date)"
    PORT_FORWARDS="" # Initialize, can be edited later

    # Download and setup VM image
    setup_vm_image
    
    # Save configuration
    save_vm_config
}

# Function to check if VM is running
is_vm_running() {
    local vm_name=$1
    # Check if QEMU process name contains the VM name or config file path
    if pgrep -f "qemu-system.*$vm_name" >/dev/null; then
        return 0
    fi
    
    # Fallback check using loaded config variables
    if load_vm_config "$vm_name" 2>/dev/null; then
        if pgrep -f "qemu-system.*$IMG_FILE" >/dev/null; then
            return 0
        fi
    fi
    return 1
}

# Function to stop a running VM
stop_vm() {
    local vm_name=$1
    
    if load_vm_config "$vm_name"; then
        if is_vm_running "$vm_name"; then
            print_status "INFO" "ðŸ›‘ Stopping VM: $vm_name"
            
            # Try graceful shutdown (SIGTERM)
            pkill -f "qemu-system.*$IMG_FILE"
            sleep 2
            
            # Check if it stopped, if not, force kill (SIGKILL)
            if is_vm_running "$vm_name"; then
                print_status "WARN" "âš ï¸  VM did not stop gracefully, forcing termination..."
                pkill -9 -f "qemu-system.*$IMG_FILE"
                sleep 1
            fi
            
            # Clean up lock files
            rm -f "${IMG_FILE}.lock" 2>/dev/null
            
            if is_vm_running "$vm_name"; then
                print_status "ERROR" "âŒ Failed to stop VM"
                return 1
            else
                print_status "SUCCESS" "âœ… VM $vm_name stopped"
            fi
        else
            print_status "INFO" "ðŸ’¤ VM $vm_name is not running"
            rm -f "${IMG_FILE}.lock" 2>/dev/null
        fi
    fi
}

# Function to start a VM
start_vm() {
    local vm_name=$1
    
    if load_vm_config "$vm_name"; then
        # Check if image is already in use or locked
        if ! check_image_lock "$IMG_FILE" "$vm_name"; then
            print_status "ERROR" "ðŸ”’ Cannot start VM: Image file is locked or in use."
            return 1
        fi
        
        # Check if VM is already running (shouldn't happen after check_image_lock, but for safety)
        if is_vm_running "$vm_name"; then
            print_status "WARN" "âš ï¸  VM '$vm_name' is already running. Stopping it first."
            stop_vm "$vm_name"
            sleep 2
        fi
        
        print_status "INFO" "ðŸš€ Starting VM: $vm_name"
        print_status "INFO" "ðŸ”Œ SSH: ssh -p $SSH_PORT $USERNAME@localhost"
        print_status "INFO" "ðŸ”‘ Password: $PASSWORD"
        
        if [[ ! -f "$IMG_FILE" ]]; then
            print_status "ERROR" "âŒ VM image file not found: $IMG_FILE"
            return 1
        fi
        
        # Base QEMU command construction
        local qemu_cmd=(
            qemu-system-x86_64
            -name "$vm_name" 
            -enable-kvm
            -m "$MEMORY"
            -smp "$CPUS"
            -cpu host
            -drive "file=$IMG_FILE,format=qcow2,if=virtio"
            -drive "file=$SEED_FILE,format=raw,if=virtio"
            -boot order=c
            -device virtio-net-pci,netdev=n0
            -netdev "user,id=n0,hostfwd=tcp::$SSH_PORT-:22"
        )

        # Add additional port forwards
        if [[ -n "$PORT_FORWARDS" ]]; then
            IFS=',' read -ra forwards <<< "$PORT_FORWARDS"
            local net_id=1
            for forward in "${forwards[@]}"; do
                IFS=':' read -r host_port guest_port <<< "$forward"
                qemu_cmd+=(-device "virtio-net-pci,netdev=n${net_id}")
                qemu_cmd+=(-netdev "user,id=n${net_id},hostfwd=tcp::$host_port-:$guest_port")
                ((net_id++))
            done
        fi

        # Add GUI or console mode
        if [[ "$GUI_MODE" == true ]]; then
            qemu_cmd+=(-vga virtio -display gtk,gl=on)
            print_status "INFO" "ðŸ–¥ï¸  Starting in GUI mode..."
        else
            qemu_cmd+=(-nographic -serial mon:stdio)
            print_status "INFO" "ðŸ“Ÿ Starting in console mode..."
            print_status "INFO" "ðŸ›‘ Press Ctrl+A then X to exit QEMU console"
        fi

        # Add performance enhancements
        qemu_cmd+=(
            -device virtio-balloon-pci
            -object rng-random,filename=/dev/urandom,id=rng0
            -device virtio-rng-pci,rng=rng0
        )

        print_status "INFO" "âš¡ Launching QEMU..."
        echo "ðŸ“Š Configuration: ${MEMORY}MB RAM, ${CPUS} CPUs, ${DISK_SIZE} disk"
        
        # Start the VM and wait for it to exit
        if ! "${qemu_cmd[@]}"; then
            print_status "ERROR" "âŒ Failed to start VM. Check QEMU/KVM setup."
            rm -f "${IMG_FILE}.lock" 2>/dev/null
            return 1
        fi
        
        print_status "INFO" "ðŸ›‘ VM $vm_name has been shut down"
    fi
}

# Function to delete a VM
delete_vm() {
    local vm_name=$1
    
    print_status "WARN" "âš ï¸  âš ï¸  This will permanently delete VM '$vm_name' and all its data!"
    read -p "$(print_status "INPUT" "ðŸ—‘ï¸  Are you absolutely sure? (y/N): ")" -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        if load_vm_config "$vm_name"; then
            if is_vm_running "$vm_name"; then
                print_status "WARN" "âš ï¸  VM is currently running. Stopping it first..."
                stop_vm "$vm_name"
                sleep 2
            fi
            
            rm -f "$IMG_FILE" "$SEED_FILE" "$VM_DIR/$vm_name.conf" "${IMG_FILE}.lock" 2>/dev/null
            
            # Clean up the potential Cow2 base image
            local base_img="$VM_DIR/$vm_name-base.img"
            if [[ -f "$base_img" ]]; then
                rm -f "$base_img" 2>/dev/null
            fi
            
            print_status "SUCCESS" "âœ… VM '$vm_name' has been deleted"
        fi
    else
        print_status "INFO" "ðŸ‘ Deletion cancelled"
    fi
}

# Function to show VM info
show_vm_info() {
    local vm_name=$1
    
    if load_vm_config "$vm_name"; then
        echo
        print_status "INFO" "ðŸ“Š VM Information: $vm_name"
        echo "========================================================"
        echo "ðŸŒ OS: $OS_TYPE ($CODENAME)"
        echo "ðŸ·ï¸  Hostname: $HOSTNAME"
        echo "ðŸ‘¤ User: $USERNAME (Pass: $PASSWORD)"
        echo "ðŸ§  Memory: $MEMORY MB"
        echo "âš¡ CPUs: $CPUS"
        echo "ðŸ’¾ Disk: $DISK_SIZE"
        echo "ðŸ”Œ SSH Access: localhost:$SSH_PORT"
        echo "ðŸŒ Other Forwards: ${PORT_FORWARDS:-None}"
        echo "ðŸ–¥ï¸  GUI Mode: $GUI_MODE"
        echo "ðŸ“… Created: $CREATED"
        echo "ðŸ’¿ Image File: $IMG_FILE"
        echo "ðŸŒ± Seed File: $SEED_FILE"
        
        if is_vm_running "$vm_name"; then
            print_status "SUCCESS" "ðŸš€ Status: Running"
        else
            print_status "WARN" "ðŸ’¤ Status: Stopped"
        fi
        
        echo "========================================================"
        echo
        read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
    fi
}

# Function to edit VM configuration
edit_vm_config() {
    local vm_name=$1
    
    if load_vm_config "$vm_name"; then
        print_status "INFO" "âœï¸  Editing VM: $vm_name (VM must be stopped for changes to apply)"
        
        while true; do
            echo
            print_status "INFO" "Current Config:"
            echo "1) Hostname: $HOSTNAME | 2) Username: $USERNAME | 3) Password: $PASSWORD"
            echo "4) SSH Port: $SSH_PORT | 5) Memory (MB): $MEMORY | 6) CPU Count: $CPUS"
            echo "7) GUI Mode: $GUI_MODE | 8) Port Forwards: ${PORT_FORWARDS:-None}"
            echo "0) Save and Back"
            
            read -p "$(print_status "INPUT" "ðŸŽ¯ Select option to edit: ")" edit_choice
            
            local config_changed=false
            local needs_seed_update=false
            
            case $edit_choice in
                1) 
                    while true; do
                        read -p "$(print_status "INPUT" "ðŸ·ï¸  Enter new hostname (current: $HOSTNAME): ")" new_val
                        new_val="${new_val:-$HOSTNAME}"
                        if validate_input "name" "$new_val"; then
                            HOSTNAME="$new_val"; config_changed=true; needs_seed_update=true; break
                        fi
                    done ;;
                2)
                    while true; do
                        read -p "$(print_status "INPUT" "ðŸ‘¤ Enter new username (current: $USERNAME): ")" new_val
                        new_val="${new_val:-$USERNAME}"
                        if validate_input "username" "$new_val"; then
                            USERNAME="$new_val"; config_changed=true; needs_seed_update=true; break
                        fi
                    done ;;
                3)
                    while true; do
                        read -p "$(print_status "INPUT" "ðŸ”‘ Enter new password (min 6 chars): ")" new_val
                        if validate_input "password" "$new_val"; then
                            PASSWORD="$new_val"; config_changed=true; needs_seed_update=true; break
                        fi
                    done ;;
                4) 
                    while true; do
                        read -p "$(print_status "INPUT" "ðŸ”Œ Enter new Host SSH Port (current: $SSH_PORT): ")" new_val
                        new_val="${new_val:-$SSH_PORT}"
                        if validate_input "port" "$new_val"; then
                            SSH_PORT="$new_val"; config_changed=true; break
                        fi
                    done ;;
                5)
                    local current_gui="N"
                    if $GUI_MODE; then current_gui="Y"; fi
                    read -p "$(print_status "INPUT" "ðŸ–¥ï¸  Enable graphical console (Y/n, current: $current_gui): ")" new_val
                    if [[ "$new_val" =~ ^[Yy]$ ]]; then GUI_MODE=true; else GUI_MODE=false; fi
                    config_changed=true; break ;;
                6)
                    print_status "INFO" "Current Forwards: $PORT_FORWARDS"
                    print_status "INFO" "Enter new forwards as HOST_PORT:GUEST_PORT, separated by commas (e.g., 8080:80,8443:443)"
                    read -p "$(print_status "INPUT" "ðŸŒ Enter new port forwards (Leave empty to clear): ")" new_val
                    PORT_FORWARDS="$new_val"; config_changed=true; break ;;
                7)
                    while true; do
                        read -p "$(print_status "INPUT" "ðŸ§  Enter new Memory in MB (current: $MEMORY): ")" new_val
                        new_val="${new_val:-$MEMORY}"
                        if validate_input "number" "$new_val" && [ "$new_val" -ge 512 ]; then
                            MEMORY="$new_val"; config_changed=true; break
                        fi
                    done ;;
                8)
                    while true; do
                        read -p "$(print_status "INPUT" "âš¡ Enter new CPU Count (current: $CPUS): ")" new_val
                        new_val="${new_val:-$CPUS}"
                        if validate_input "number" "$new_val" && [ "$new_val" -ge 1 ]; then
                            CPUS="$new_val"; config_changed=true; break
                        fi
                    done ;;
                0) break ;;
                *) print_status "ERROR" "âŒ Invalid selection"; read -p "" ;;
            esac
            
            if $config_changed; then
                save_vm_config
            fi
            if $needs_seed_update; then
                print_status "INFO" "ðŸ”„ User credentials or hostname changed. Recreating cloud-init seed..."
                setup_vm_image
            fi
        done
        print_status "SUCCESS" "âœ… Configuration saved."
    fi
}

# Function to resize VM disk
resize_vm_disk() {
    local vm_name=$1
    
    if load_vm_config "$vm_name"; then
        if is_vm_running "$vm_name"; then
            print_status "ERROR" "âŒ Cannot resize disk while VM is running. Please stop the VM first."
            return 1
        fi
        
        print_status "INFO" "ðŸ’¾ Current disk size: $DISK_SIZE"
        
        while true; do
            read -p "$(print_status "INPUT" "ðŸ“ˆ Enter new disk size (e.g., 50G): ")" new_disk_size
            if validate_input "size" "$new_disk_size"; then
                # WARNING: qemu-img resize handles size increase well. Decreasing is dangerous.
                # Here we only allow increases to prevent data loss via qemu-img bug/truncation.
                
                # Simple check: new size must be greater than current size
                local current_size_bytes=$(numfmt --from=auto --to=si "$DISK_SIZE" | sed 's/.$//')
                local new_size_bytes=$(numfmt --from=auto --to=si "$new_disk_size" | sed 's/.$//')
                
                if [ "$new_size_bytes" -le "$current_size_bytes" ]; then
                    print_status "ERROR" "âŒ New size must be LARGER than current size ($DISK_SIZE) to prevent data loss."
                    continue
                fi

                print_status "INFO" "ðŸ“ˆ Resizing disk to $new_disk_size..."
                if qemu-img resize "$IMG_FILE" "$new_disk_size"; then
                    DISK_SIZE="$new_disk_size"
                    save_vm_config
                    print_status "SUCCESS" "âœ… Disk resized successfully to $new_disk_size. You may need to resize the partition inside the VM."
                else
                    print_status "ERROR" "âŒ Failed to resize disk"
                    return 1
                fi
                break
            fi
        done
    fi
}

# Function to fix VM issues
fix_vm_issues() {
    local vm_name=$1
    
    if load_vm_config "$vm_name"; then
        print_status "INFO" "ðŸ”§ Fixing issues for VM: $vm_name"
        
        while true; do
            echo "ðŸ”§ Select issue to fix:"
            echo "  1) ðŸ”“ Remove lock files"
            echo "  2) ðŸŒ± Recreate cloud-init seed image (if user/network config failed)"
            echo "  3) â†©ï¸  Back to VM menu"
            
            read -p "$(print_status "INPUT" "ðŸŽ¯ Enter your choice: ")" fix_choice
            
            case $fix_choice in
                1)
                    if [[ -f "${IMG_FILE}.lock" ]]; then
                        rm -f "${IMG_FILE}.lock" 2>/dev/null
                        print_status "SUCCESS" "âœ… Removed lock file: ${IMG_FILE}.lock"
                    else
                        print_status "INFO" "â„¹ï¸  No lock file found to remove."
                    fi
                    ;;
                2)
                    print_status "INFO" "ðŸ”„ Recreating cloud-init seed image..."
                    # This calls setup_vm_image, which recreates the seed ISO
                    setup_vm_image
                    ;;
                3)
                    break
                    ;;
                *)
                    print_status "ERROR" "âŒ Invalid selection"
                    ;;
            esac
            read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
            display_header
            print_status "INFO" "ðŸ”§ Fixing issues for VM: $vm_name"
        done
    fi
}

# Function to show VM performance metrics
show_vm_performance() {
    local vm_name=$1
    
    if load_vm_config "$vm_name"; then
        print_status "INFO" "ðŸ“Š Performance metrics for VM: $vm_name"
        echo "========================================================"
        
        if is_vm_running "$vm_name"; then
            local qemu_pid=$(pgrep -f "qemu-system.*$IMG_FILE" | head -1)
            if [[ -n "$qemu_pid" ]]; then
                print_status "INFO" "âš¡ QEMU Process Stats (PID $qemu_pid):"
                # Output key process stats (CPU, Memory, VIRT/RES/SHR size)
                ps -p "$qemu_pid" -o pid,%cpu,%mem,sz,rss,vsz,cmd --no-headers
            else
                print_status "WARN" "âš ï¸  QEMU process not found."
            fi
        else
            print_status "WARN" "ðŸ’¤ VM is not running. Cannot show live metrics."
        fi
        
        echo
        print_status "INFO" "ðŸ’¾ Disk File Size:"
        du -h "$IMG_FILE" 2>/dev/null || echo "File not found."
        
        echo "========================================================"
        read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
    fi
}

# Function to manage a selected VM
vm_management_menu() {
    local vm_name=$1
    
    while true; do
        display_header
        print_status "INFO" "ðŸš€ Managing VM: $vm_name"
        echo "========================================================"
        
        # Check if running and show status
        if is_vm_running "$vm_name"; then
            print_status "SUCCESS" "ðŸš€ Status: Running (PID: $(pgrep -f "qemu-system.*$vm_name" | head -1))"
            local run_text="ðŸ›‘ Stop VM"
        else
            print_status "WARN" "ðŸ’¤ Status: Stopped"
            local run_text="ðŸš€ Start VM"
        fi
        
        echo "========================================================"
        
        echo "  1) $run_text"
        echo "  2) ðŸ“Š Show Info"
        echo "  3) âœï¸  Edit Configuration"
        echo "  4) ðŸ’¾ Resize Disk Image (Stop VM first)"
        echo "  5) ðŸ”§ Fix Common Issues"
        echo "  6) ðŸ“ˆ Show Performance Metrics"
        echo "  7) ðŸ—‘ï¸  Delete VM (Permanent)"
        echo "  0) â†©ï¸  Back to Main Menu"
        
        read -p "$(print_status "INPUT" "ðŸŽ¯ Enter your choice: ")" action_choice
        
        display_header # Clear screen before running action
        
        case $action_choice in
            1)
                if is_vm_running "$vm_name"; then
                    stop_vm "$vm_name"
                else
                    start_vm "$vm_name"
                fi
                read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
                ;;
            2) show_vm_info "$vm_name" ;;
            3) edit_vm_config "$vm_name" ;;
            4) resize_vm_disk "$vm_name" ;;
            5) fix_vm_issues "$vm_name" ;;
            6) show_vm_performance "$vm_name" ;;
            7)  
                delete_vm "$vm_name"
                return # Exit back to main menu after deletion
                ;;
            0) return ;;
            *) print_status "ERROR" "âŒ Invalid selection"
               read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
               ;;
        esac
    done
}

# --- Main Program Entry Point ---
main_menu() {
    check_dependencies
    
    while true; do
        display_header
        
        print_status "INFO" "ðŸ“¦ VM Directory: $VM_DIR"
        echo "========================================================================"
        echo "                     M A I N   M E N U"
        echo "========================================================================"
        
        echo "  1) ðŸ†• Create New VM"
        echo "  2) ðŸš€ Manage Existing VM"
        echo "  0) âŒ Exit"
        echo
        
        read -p "$(print_status "INPUT" "ðŸŽ¯ Enter your choice: ")" main_choice
        
        case $main_choice in
            1)
                display_header
                create_new_vm
                read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
                cleanup
                ;;
            2)
                local vm_list=$(get_vm_list)
                if [[ -z "$vm_list" ]]; then
                    print_status "WARN" "âš ï¸  No VMs found in $VM_DIR."
                    read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
                    continue
                fi
                
                display_header
                print_status "INFO" "ðŸŒ Select a VM to manage:"
                local i=1
                local selected_vms=()
                for vm in $vm_list; do
                    echo "  $i) $vm"
                    selected_vms[$i]="$vm"
                    ((i++))
                done
                echo "  0) â†©ï¸  Back to Main Menu"
                
                while true; do
                    read -p "$(print_status "INPUT" "ðŸŽ¯ Enter VM number (1-$((i-1))) or 0: ")" vm_choice
                    if [[ "$vm_choice" =~ ^[0-9]+$ ]] && [ "$vm_choice" -ge 0 ] && [ "$vm_choice" -lt "$i" ]; then
                        if [ "$vm_choice" -eq 0 ]; then
                            break
                        fi
                        local selected_vm="${selected_vms[$vm_choice]}"
                        vm_management_menu "$selected_vm"
                        break
                    else
                        print_status "ERROR" "âŒ Invalid selection. Try again."
                    fi
                done
                ;;
            0)
                print_status "INFO" "ðŸ‘‹ Exiting VM Manager. Goodbye!"
                exit 0
                ;;
            *)
                print_status "ERROR" "âŒ Invalid selection"
                read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
                ;;
        esac
    done
}

# --- Execute Main Program ---
main_menu
